What is Microfrontend Architecture (Simple Explanation)

Microfrontend = breaking a big frontend into smaller independent apps.

Example:
Microfrontend	Purpose
remote-app	A small independent React app (like product list, navbar, profile)
host-app	Main application that loads remote apps dynamically
other remotes	(Optional) checkout-app, user-app, admin-app

Each one is built separately, runs on its own port, can be deployed separately, can be updated without touching others.
The host-app loads remote modules at runtime, not during build.

ğŸ”Œ What is Module Federation? (Important)
Module Federation (Webpack 5) allows one app to use code from another app at runtime.

1ï¸âƒ£ Remote app â†’ exposes components
2ï¸âƒ£ Host app â†’ imports those exposed components
ğŸ“¦ Remote App (microfrontend) â€” /remote-app

This app exposes components so other apps can use them.

âœ” What remote-app does:
Runs independently on port 3001
Renders its own App normally
Exposes components so host can load them

ğŸ—‚ï¸ Remote App â€” File-by-file Explanation
ğŸ“„ package.json

Defines dependencies and scripts.
Important parts:
"start": "webpack serve --mode development --open"

Runs the remote app on port 3001.
ğŸ“„ webpack.config.js (MOST IMPORTANT)
This file tells Webpack:
1) This is a remote microfrontend
name: "remote"
filename: "remoteEntry.js"

Webpack will generate this file at runtime:
http://localhost:3001/remoteEntry.js

This file acts like an API for microfrontends â€” host-app uses it to load components.
2) Exposing components
exposes: {
  './RemoteApp': './src/App.js'
}

This means:
another app can import this component as: import RemoteApp from "remote/RemoteApp";
Because /src/App.js is exposed.

3) Shared dependencies
shared: { 
  react: { singleton: true }, 
  'react-dom': { singleton: true } 
}

Prevents loading multiple copies of React, Ensures React instance is shared between apps
ğŸ“„ /remote-app/src/index.js

Always like: import('./bootstrap');

This enables async loading, required by Module Federation.
ğŸ“„ /remote-app/src/bootstrap.js

React 18 setup:
import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';

const root = createRoot(document.getElementById('root'));
root.render(<App />);

This renders the remote app when opened directly.
ğŸ“„ /remote-app/src/App.js

Your microfrontend component:
export default function App() {
  return <h2>Hello from Remote Microfrontend!</h2>;
}

ğŸ“„ /remote-app/public/index.html : Simple HTML file that loads the React app.

ğŸ  Host App (Main Application) â€” /host-app
âœ” What host-app does:
Runs on port 3000
Loads remote-app

Displays its components inside host UI
ğŸ—‚ï¸ Host App â€” File-by-file Explanation
ğŸ“„ package.json

Same as remote, but name is host-app.
Runs host server on port 3000.
ğŸ“„ webpack.config.js

ğŸ”¥ THIS IS WHERE HOST LOADS REMOTE
1) Host name : name: 'host'
2) It has no exposes : Host is not sharing anything.
3) Host loads remote-app
remotes: {
  remote: "remote@http://localhost:3001/remoteEntry.js"
}

This means:
Host imports remote modules from this URL, Remote microfrontend is connected over HTTP
This line is the heart of Module Federation.

How host imports remote component:
const RemoteApp = React.lazy(() => import("remote/RemoteApp"));

This matches:
exposes: {
  './RemoteApp': './src/App.js'
}
So the host loads /remote-app/src/App.js dynamically at runtime.

ğŸ“„ /host-app/src/App.js
const RemoteApp = React.lazy(() => import("remote/RemoteApp"));

Inside JSX:
<React.Suspense fallback={<div>Loading Remote...</div>}>
  <RemoteApp />
</React.Suspense>

This means:
âœ” Host loads remoteâ€™s App
âœ” Renders it like a normal React component
âœ” Doesnâ€™t need its code inside the host build

/host-app/src/bootstrap.js

React 18 root setup.
/host-app/public/index.html

Basic HTML.
ğŸ§  How Microfrontend Loading Really Works
1ï¸âƒ£ User opens host-app (localhost:3000)
Host downloads: host code, its own webpack bundle

2ï¸âƒ£ Host sees:
import("remote/RemoteApp")

3ï¸âƒ£ Host loads remoteEntry.js from URL:
http://localhost:3001/remoteEntry.js
This file tells host: What modules remote exposes
How to load them
What shared dependencies exist

4ï¸âƒ£ Host pulls remoteâ€™s App component dynamically
(Only when needed, not during build)

5ï¸âƒ£ Host renders remote component inside host UI
ğŸ“¦ Hostâ€“Remote Example Relationship
Concept	In host-app	In remote-app
Name	host	remote
Role	loads others	exposes components
Module Federation	remotes: { remote: URL }	exposes: { './RemoteApp': file }
Port	3000	3001
remoteEntry.js	loads from remote	generated by remote-app

ğŸ§© Summary (Very Simple)
Remote-app: Independent app
Exposes components : Runs on 3001

Generates /remoteEntry.js
Host-app: Main application

Imports exposed components from remote: Runs on 3000

Loads remote at runtime
